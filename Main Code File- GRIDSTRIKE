<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRIDSTRIKE</title>
    <!-- Fonts: Syncopate for titles, Exo 2 for technical UI -->
    <link href="https://fonts.googleapis.com/css2?family=Syncopate:wght@700&family=Exo+2:wght@100;900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Exo 2', sans-serif;
            background-color: #000;
            touch-action: manipulation;
            overflow: hidden;
            min-height: 100vh;
            width: 100vw;
            color: white;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* High-Contrast Aether Shader Background */
        #bg-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2;
            display: block; filter: contrast(1.4) brightness(1.1);
        }

        .grain {
            position: fixed; top: -50%; left: -50%; width: 200%; height: 200%; z-index: -1; pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 600 600' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            background-repeat: repeat; opacity: 0.05; animation: grainAnimation 1s steps(4) infinite;
        }

        @keyframes grainAnimation {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-1%, -0.5%); }
            50% { transform: translate(1%, 0.5%); }
            75% { transform: translate(-0.5%, 1%); }
        }

        .title-font {
            font-family: 'Syncopate', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: -0.05em; 
            font-size: 1.5rem; 
            transform: scaleX(1.1); 
            display: inline-block;
        }

        #intro-screen {
            transition: opacity 0.8s ease, transform 0.8s ease, visibility 0.8s;
            background: transparent;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            padding-top: 15vh;
            z-index: 200; position: fixed; inset: 0;
            overflow: hidden;
        }
        #intro-screen.fade-out { opacity: 0; transform: translateY(50px); visibility: hidden; }

        .planet-horizon {
            position: absolute;
            bottom: -65vh;
            left: 50%;
            transform: translateX(-50%);
            width: 160vw;
            height: 120vh;
            background: radial-gradient(circle at 50% 0%, #222222 0%, #0a0a0a 40%, #000000 60%);
            border-radius: 50%;
            z-index: 0;
            box-shadow: 0 -30px 80px rgba(180, 180, 180, 0.12), 0 -10px 40px rgba(255, 255, 255, 0.05), 0 -20px 100px rgba(0,0,0,1), inset 0 2px 10px rgba(255,255,255,0.15);
            pointer-events: none;
        }

        /* Unified HUD Layout */
        #main-layout {
            transition: opacity 1s ease 0.3s, transform 1s ease 0.3s;
            display: flex; flex-direction: row; align-items: center; justify-content: center;
            width: 100%; height: 100vh; position: relative; gap: 4rem;
        }
        #main-layout.hidden { opacity: 0; transform: translateY(20px); display: none !important; }
        #main-layout.visible { opacity: 1; transform: translateY(0); display: flex; }

        /* Left Side HUD - Progress atop Identity */
        #left-info-panel { width: 280px; display: flex; flex-direction: column; align-items: flex-end; z-index: 100; flex-shrink: 0; }
        #progress-container { width: 100%; display: flex; flex-direction: column; align-items: flex-end; margin-bottom: 1.5rem; }
        .progress-cluster { display: flex; align-items: center; gap: 0; position: relative; }
        .dot { width: 12px; height: 12px; border-radius: 50%; border: 1.5px solid rgba(255, 255, 255, 0.2); transition: 0.4s; position: relative; z-index: 2; flex-shrink: 0; }
        .dot.active { background: #fff; box-shadow: 0 0 12px #fff; border-color: #fff; }
        .progress-line { height: 1.5px; width: 32px; background: rgba(255,255,255,0.1); flex-shrink: 0; }
        .progress-line.filled { background: #fff; box-shadow: 0 0 8px #fff; }

        .boss-series-box {
            border: 1.5px solid #FF0066; border-radius: 20px; padding: 4px 10px; display: flex; gap: 10px;
            box-shadow: 0 0 15px rgba(255, 0, 102, 0.4); background: rgba(255, 0, 102, 0.1); flex-shrink: 0;
            cursor: pointer; transition: 0.3s;
        }
        .dot-boss { 
            width: 10px; height: 10px; border-radius: 50%; 
            background: rgba(255, 255, 255, 0.15); 
            border: 1px solid rgba(255, 255, 255, 0.3); 
            transition: background 0.4s, box-shadow 0.4s, border-color 0.4s; 
        }
        .dot-boss.win { background: #FF0066; box-shadow: 0 0 12px #FF0066; border-color: #FF0066; }

        #aether-title { text-align: right; color: #FF0066; margin-bottom: 2px; line-height: 1; }
        #challenger-label { text-align: right; font-weight: 300; font-size: 0.95rem; margin-top: 0px; color: rgba(255, 255, 255, 0.7); }

        /* GRID GEOMETRY LOCK: Strictly defined 1:1 Square */
        .board-wrapper { display: flex; flex-direction: column; align-items: center; gap: 3.5rem; z-index: 10; flex-shrink: 0; }
        .board-slider {
            position: relative; 
            width: 80vmin;
            height: 80vmin;
            max-width: 450px;
            max-height: 450px;
            aspect-ratio: 1 / 1;
            border-radius: 12px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.8); background: rgba(255,255,255,0.02);
            isolation: isolate; flex-shrink: 0;
        }
        .board-container { width: 100%; height: 100%; transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1); position: relative; overflow: hidden; border-radius: 12px; }
        .chess-board { display: grid; grid-template-columns: repeat(5, 1fr); grid-template-rows: repeat(5, 1fr); gap: 4px; width: 100%; height: 100%; position: relative; z-index: 1; }
        
        .square { display: flex; justify-content: center; align-items: center; position: relative; border-radius: 4px; backdrop-filter: blur(8px); box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.05); z-index: 5; }
        .square.light { background: rgba(42, 42, 42, 0.85); }
        .square.dark { background: rgba(21, 21, 21, 0.85); }

        .square.selected::after { content: ''; position: absolute; inset: 0; border-radius: 4px; z-index: 10; border: 3px solid #fff; box-shadow: 0 0 25px #fff; background-color: rgba(255, 255, 255, 0.2); pointer-events: none; }
        .square.in-danger::after { content: ''; position: absolute; inset: 0; border-radius: 4px; z-index: 10; border: 3px solid #ff0000; box-shadow: 0 0 25px #ff0000; background-color: rgba(255, 0, 0, 0.2); animation: dangerPulse 0.8s infinite alternate; pointer-events: none; }
        @keyframes dangerPulse { from { opacity: 0.5; } to { opacity: 1; } }

        #active-move-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 100; }
        .move-dot.active { fill: #fff; stroke: #fff; stroke-width: 1px; r: 2px; filter: drop-shadow(0 0 8px #fff); }
        
        .piece-wrapper { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; position: relative; z-index: 60; transition: transform 0.35s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.35s ease; }
        .piece-svg { cursor: pointer; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.8)); transition: transform 0.2s ease; }
        .commander-svg { width: 78%; height: 78%; }
        .guardian-svg, .assassin-svg { width: 64%; height: 64%; }
        .pawn-svg { width: 48%; height: 48%; }

        /* Power Move: Simplified Opacity Drop and Reveal */
        .piece-power-glow { filter: drop-shadow(0 0 25px #fff) brightness(1.2) !important; }
        @keyframes powerFadeOut { 0% { opacity: 1; } 100% { opacity: 0; } }
        @keyframes powerFadeIn { 0% { opacity: 0; } 100% { opacity: 1; } }
        .power-fade-out { animation: powerFadeOut 0.3s forwards cubic-bezier(0.4, 0, 0.2, 1); }
        .power-fade-in { animation: powerFadeIn 0.3s forwards cubic-bezier(0.4, 0, 0.2, 1); }

        /* PREMIUM BUTTON CARD TREATMENT */
        .btn-premium {
            background: linear-gradient(#1c1c1e, #1c1c1e) padding-box, linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.05) 100%) border-box;
            border: 1.5px solid transparent; border-radius: 1.25rem; cursor: pointer; box-shadow: 0 10px 25px rgba(0,0,0,0.5); transition: 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            display: flex; align-items: center; justify-content: center; text-align: center; color: white; outline: none;
            font-family: 'Syncopate', sans-serif; text-transform: uppercase;
        }
        .btn-premium:hover { transform: scale(1.02); box-shadow: 0 0 35px rgba(255, 255, 255, 0.4); border-color: rgba(255, 255, 255, 0.5); }

        #quit-button { position: fixed; bottom: 2rem; left: 2rem; padding: 0.8rem 2.2rem; font-size: 0.65rem; z-index: 150; }
        #next-challenger-btn { padding: 1.8rem 3.5rem; font-size: 0.9rem; letter-spacing: 0.1em; border-radius: 1.5rem; }

        /* Power Cards Hand */
        #card-hand { display: flex; justify-content: center; gap: 1rem; width: min(80vmin, 450px); flex-shrink: 0; }
        .ability-card {
            background: linear-gradient(#1c1c1e, #1c1c1e) padding-box, linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.05) 100%) border-box;
            border: 1.5px solid transparent; border-radius: 1.5rem; cursor: pointer; box-shadow: 0 10px 20px rgba(0,0,0,0.4); transition: transform 0.4s cubic-bezier(0.23, 1, 0.32, 1), box-shadow 0.4s ease;
            display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; position: relative; outline: none; padding: 1.5rem 0.75rem; flex: 1;
        }
        .ability-card.selected { border: 2px solid #fff !important; transform: translateY(-15px) scale(1.05); background: linear-gradient(#2c2c2e, #1c1c1e) padding-box, linear-gradient(135deg, #fff 0%, rgba(255, 255, 255, 0.5) 100%) border-box !important; box-shadow: 0 0 30px rgba(255, 255, 255, 0.5); z-index: 200; }
        .ability-card.executing-power { box-shadow: 0 0 65px rgba(255, 255, 255, 0.8) !important; border-color: #fff !important; transform: translateY(-20px) scale(1.1) !important; }
        .ability-card.disabled { opacity: 0.15; pointer-events: none; filter: grayscale(1); }

        .card-title { font-family: 'Syncopate', sans-serif; font-size: 0.7rem; letter-spacing: -0.02em; margin-bottom: 0.5rem; text-transform: uppercase; color: white; }
        .card-desc { font-size: 0.6rem; color: rgba(255,255,255,0.4); font-weight: 100; line-height: 1.3; }

        /* Unit Promotion Localized Overlay */
        #promotion-modal {
            position: absolute; inset: 0;
            background: rgba(0, 0, 0, 0.75); z-index: 800;
            backdrop-filter: blur(12px); border-radius: 12px;
            display: none; align-items: center; justify-content: center;
        }
        #promotion-modal.visible { display: flex; }
        #promotion-modal .modal-content {
            padding: 3rem; gap: 2rem; border-radius: 2.5rem;
            background: linear-gradient(#1c1c1e, #1c1c1e) padding-box, linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.05) 100%) border-box;
            border: 1.5px solid rgba(255, 255, 255, 0.1); text-align: center;
            box-shadow: 0 40px 100px rgba(0,0,0,0.95);
        }
        .promotion-option { width: 130px; height: 160px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 15px; cursor: pointer; transition: 0.3s; }
        .promotion-option svg { width: 85px; height: 85px; }

        #next-challenger-overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; z-index: 500; background: rgba(0,0,0,0.85); transition: 0.4s; border-radius: 12px; }
        #next-challenger-overlay.visible { display: flex; }

        #right-captured-panel { position: absolute; left: calc(100% + 2rem); top: 0; bottom: 0; display: flex; flex-direction: column; justify-content: space-between; width: 52px; z-index: 100; flex-shrink: 0; }
        .captured-piece-svg { width: 52px; height: 52px; margin: 0; display: flex; justify-content: center; opacity: 0.8; }

        .particle { position: absolute; width: 10px; height: 10px; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); pointer-events: none; z-index: 1000; opacity: 0; }
        @keyframes particleFly { 0% { transform: translate(0, 0) scale(1.8) rotate(var(--start-rot)); opacity: 0.75; } 70% { transform: translate(var(--dx), var(--dy)) scale(0.6) rotate(var(--mid-rot)); opacity: 0.75; } 100% { transform: translate(var(--dx), var(--dy)) scale(0) rotate(var(--end-rot)); opacity: 0; } }
        .impact-shake { animation: boardImpact 0.25s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes boardImpact { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(4px, -2px); } 50% { transform: translate(-4px, 2px); } 75% { transform: translate(2px, 2px); } }

        .global-modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 1000; display: flex; justify-content: center; align-items: center; opacity: 0; visibility: hidden; transition: 0.4s; backdrop-filter: blur(12px); }
        .global-modal-backdrop.visible { opacity: 1; visibility: visible; }
    </style>
</head>
<body>

    <canvas id="bg-canvas"></canvas>
    <div class="grain"></div>

    <div id="intro-screen">
        <div class="planet-horizon"></div>
        <h1 class="title-font text-center text-white mb-12 relative z-10" style="font-size: 5rem;">GRIDSTRIKE</h1>
        <button id="start-challenge-btn" class="btn-premium px-16 py-6 title-font text-lg tracking-[0.1em] relative z-10 mt-auto mb-[15vh]">CHALLENGE AETHER</button>
    </div>

    <div id="main-layout" class="hidden">
        <!-- Sidebar reprioritized: Progress atop Identity -->
        <div id="left-info-panel">
            <div id="progress-container">
                <div class="progress-cluster">
                    <div class="dot" id="dot-0"></div><div class="progress-line" id="line-0"></div>
                    <div class="dot" id="dot-1"></div><div class="progress-line" id="line-1"></div>
                    <div class="dot" id="dot-2"></div><div class="progress-line" id="line-2"></div>
                    <div id="debug-skip-boss" class="boss-series-box" title="Initialize Boss Match Sequence">
                        <div class="dot-boss" id="boss-match-0"></div>
                        <div class="dot-boss" id="boss-match-1"></div>
                        <div class="dot-boss" id="boss-match-2"></div>
                    </div>
                </div>
            </div>
            
            <h1 id="aether-title" class="title-font text-5xl">AETHER</h1>
            <p id="challenger-label" class="title-font uppercase tracking-widest">The Apprentice</p>
            
            <div class="text-right mt-12"><p id="turn-info" class="text-2xl font-thin text-white/90">Your Turn</p></div>
        </div>

        <div class="board-wrapper">
             <div class="board-slider" id="board-shell">
                <div id="board-container" class="board-container"><div id="chess-board" class="chess-board"></div></div>
                
                <div id="promotion-modal">
                    <div class="modal-content">
                        <h2 class="title-font text-white uppercase text-sm tracking-[0.3em] mb-8">Unit Promotion</h2>
                        <div class="flex gap-12">
                            <div id="promote-guardian" class="promotion-option ability-card">
                                <div id="promo-guardian-icon"></div>
                                <span class="card-title text-[0.7rem] mt-4">Guardian</span>
                            </div>
                            <div id="promote-assassin" class="promotion-option ability-card">
                                <div id="promo-assassin-icon"></div>
                                <span class="card-title text-[0.7rem] mt-4">Assassin</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="next-challenger-overlay">
                    <button id="next-challenger-btn" class="btn-premium">NEXT CHALLENGER</button>
                </div>
                
                <div id="right-captured-panel">
                    <div class="captured-column"><div id="black-captured-pieces" class="flex flex-col gap-1 items-center min-h-[10px]"></div></div>
                    <div class="captured-column mt-auto"><div id="white-captured-pieces" class="flex flex-col gap-1 items-center min-h-[10px]"></div></div>
                </div>
            </div>
            
            <div id="card-hand">
                <div id="card-knights-leap" class="ability-card"><h3 class="card-title">KNIGHT'S LEAP</h3><p class="card-desc">L-shape combat jump.</p></div>
                <div id="card-phase-shift" class="ability-card"><h3 class="card-title">PHASE SHIFT</h3><p class="card-desc">Teleport to any void.</p></div>
                <div id="card-assassins-rage" class="ability-card"><h3 class="card-title">ASSASSINS RAGE</h3><p class="card-desc">Assassin gets an extra move on capture.</p></div>
            </div>
        </div>
        <button id="quit-button" class="btn-premium">QUIT</button>
    </div>

    <!-- Modals -->
    <div id="skip-boss-modal" class="global-modal-backdrop"><div class="modal-content"><h2 class="title-font text-white uppercase text-xl">Tactical Override</h2><p class="text-sm font-thin text-white/60 -mt-4 uppercase tracking-[0.2em]">Initialize Boss Sequence?</p><div class="flex gap-4"><button id="skip-boss-confirm" class="btn-premium px-8 py-3 title-font text-xs uppercase tracking-widest">Confirm</button><button id="skip-boss-cancel" class="btn-premium px-8 py-3 title-font text-xs uppercase tracking-widest opacity-60">Cancel</button></div></div></div>
    <div id="game-over-modal" class="global-modal-backdrop"><div class="modal-content"><h2 id="winner-message" class="title-font text-white uppercase" style="font-size: 2.2rem;"></h2><button id="final-reset-btn" class="btn-premium px-16 py-5 title-font text-xl uppercase tracking-widest">CHALLENGE AETHER</button></div></div>

    <script>
        /* --- CORE UTILITIES --- */
        const el = id => document.getElementById(id);

        /* --- GLOBAL ASSETS --- */
        const PIECES_SVG = {
            commander: (color) => {
                const isW = color === 'white', sG = isW ? 'grad_cmd_w_star' : 'grad_cmd_b_star', cG = isW ? 'grad_cmd_w_circle' : 'grad_cmd_b_circle';
                return `<svg class="piece-svg commander-svg" viewBox="0 0 100 100"><defs><linearGradient id="grad_cmd_b_star" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#9B9B9B" /><stop offset="100%" stop-color="#222222" /></linearGradient><linearGradient id="grad_cmd_b_circle" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#D1D1D1" /><stop offset="100%" stop-color="#1A1A1A" /></linearGradient><linearGradient id="grad_cmd_w_star" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#FFFFFF" /><stop offset="100%" stop-color="#999999" /></linearGradient><linearGradient id="grad_cmd_w_circle" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#F5F5F5" /><stop offset="100%" stop-color="#999999" /></linearGradient></defs><polygon fill="url(#${sG})" points="50,1 58.8,17.1 73,8 75.8,24.5 93,25 87.2,40.7 99,50 87.2,59.3 93,75 75.8,75.5 73,92 58.8,82.9 50,99 41.2,82.9 27,92 24.2,75.5 7,75 12.8,59.3 1,50 12.8,40.7 7,25 24.2,24.5 27,8 41.2,17.1" /><circle cx="50" cy="50" r="28" fill="url(#${cG})" /></svg>`;
            },
            guardian: (color) => {
                const isW = color === 'white', c = isW ? ['#FFFFFF', '#CCCCCC', '#BBBBBB', '#999999'] : ['#999999', '#666666', '#444444', '#111111'];
                return `<svg class="piece-svg guardian-svg" viewBox="0 0 100 100"><polygon points="0,0 100,0 80,20 20,20" fill="${c[0]}"/><polygon points="0,0 20,20 20,80 0,100" fill="${c[1]}"/><polygon points="100,0 80,20 80,80 100,100" fill="${c[2]}"/><polygon points="0,100 100,100 80,80 20,80" fill="${c[3]}"/><rect x="20" y="20" width="60" height="60" fill="${c[1]}" /><g transform="translate(35, 35) scale(0.3)"><polygon points="0,0 100,0 50,50" fill="${c[0]}"/><polygon points="100,0 100,100 50,50" fill="${c[1]}"/><polygon points="0,100 100,100 50,50" fill="${c[3]}"/><polygon points="0,0 0,100 50,50" fill="${c[2]}"/></g></svg>`;
            },
            assassin: (color) => {
                const isW = color === 'white', c = isW ? ['#FFFFFF', '#EAEAEA', '#C0C0C0', '#707070'] : ['#999999', '#666666', '#444444', '#111111'];
                return `<svg class="piece-svg assassin-svg" viewBox="0 0 100 100"><polygon points="50,0 50,50 0,50" fill="${c[0]}"/><polygon points="50,0 100,50 50,50" fill="${c[1]}"/><polygon points="0,50 50,50 50,100" fill="${c[2]}"/><polygon points="100,50 50,100 50,50" fill="${c[3]}"/><g transform="translate(35, 35) scale(0.3)"><polygon points="0,0 100,0 50,50" fill="${c[0]}"/><polygon points="100,0 100,100 50,50" fill="${c[1]}"/><polygon points="0,100 100,100 50,50" fill="${c[3]}"/><polygon points="0,0 0,100 50,50" fill="${c[2]}"/></g></svg>`;
            },
            pawn: (color) => {
                 const isW = color === 'white', c = isW ? ['#FFFFFF', '#EAEAEA', '#C0C0C0', '#707070'] : ['#999999', '#666666', '#444444', '#111111'];
                 return `<svg class="piece-svg pawn-svg" viewBox="0 0 100 100"><polygon points="0,0 100,0 50,50" fill="${c[0]}"/><polygon points="100,0 100,100 50,50" fill="${c[1]}"/><polygon points="0,100 100,100 50,50" fill="${c[3]}"/><polygon points="0,0 0,100 50,50" fill="${c[2]}"/></svg>`;
            }
        };

        /* --- GLOBAL STATE --- */
        var currentStage = 0, board = [], currentPlayer = 'white', selectedPiece = null, validMoves = [], isGameOver = false, isPlayerTurn = true, isAnimating = false;
        var commanderSwapUsed = { white: false, black: false }, capturedByWhite = [], capturedByBlack = [], activeCard = null, runCardsUsed = {};
        var bossResults = [], bossModeInterpolation = 0, bossModeTarget = 0;
        var tierTitles = ["The Apprentice", "The Adept", "The Exemplar", "The Grandmaster"];

        /* --- LOGICAL HELPERS (HOISTED) --- */
        function isWithinBoard(r, c) { return r >= 0 && r < 5 && c >= 0 && c < 5; }
        function findPiece(t, col) { for(let r=0; r<5; r++) for(let c=0; c<5; c++) if(board[r] && board[r][c] && board[r][c].piece === t && board[r][c].color === col) return {r, c}; return null; }
        function getAllMoves(b, col) { const ms = []; for (let r=0; r<5; r++) for (let c=0; c<5; c++) if (b[r] && b[r][c] && b[r][c].color === col) getValidMoves(b[r][c], r, c, b).forEach(m => ms.push({from: {r,c}, to: m})); return ms; }
        function isSquareAttacked(r, c, attCol, b = board) { return getAllMoves(b, attCol).some(m => m.to.r === r && m.to.c === c); }
        function calculateCommanderDanger() { const d = []; const wC = findPiece('commander', 'white'), bC = findPiece('commander', 'black'); if (wC && isSquareAttacked(wC.r, wC.c, 'black')) d.push(wC); if (bC && isSquareAttacked(bC.r, bC.c, 'white')) d.push(bC); return d; }
        function getBoardAfterMove(b, m) { const n = JSON.parse(JSON.stringify(b)); if(n[m.to.r] && n[m.from.r]) { n[m.to.r][m.to.c] = n[m.from.r][m.from.c]; n[m.from.r][m.from.c] = null; } return n; }
        function getValidMoves(p, r, c, b = board) {
            if (!p) return []; const ms = [], col = p.color;
            if (p.piece === 'pawn') { const dir = col === 'white' ? -1 : 1; if (isWithinBoard(r+dir, c) && b[r+dir] && !b[r+dir][c]) ms.push({r: r+dir, c}); [[r+dir, c-1], [r+dir, c+1]].forEach(([nr, nc]) => { if (isWithinBoard(nr, nc) && b[nr] && b[nr][nc] && b[nr][nc].color !== col) ms.push({r: nr, c: nc}); }); }
            else if (p.piece === 'guardian') { [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr, dc]) => { for (let i=1; i<=2; i++) { const nr = r+dr*i, nc = c+dc*i; if (!isWithinBoard(nr, nc)) break; if (b[nr] && b[nr][nc]) { if(b[nr][nc].color !== col) ms.push({r: nr, c: nc}); break; } ms.push({r: nr, c: nc}); } }); }
            else if (p.piece === 'assassin') { [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr, dc]) => { const nr = r+dr, nc = c+dc; if (isWithinBoard(nr, nc)) { if (!b[nr] || !b[nr][nc] || b[nr][nc].color !== col) ms.push({r: nr, c: nc}); const nr2 = r+dr*2, nc2 = c+dc*2; if (isWithinBoard(nr2, nc2) && (!b[nr] || !b[nr][nc] || b[nr][nc].color === col)) if (!b[nr2] || !b[nr2][nc2] || b[nr2][nc2].color !== col) ms.push({r: nr2, c: nc2}); } }); }
            else if (p.piece === 'commander') { for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) { if (dr===0 && dc===0) continue; const nr = r+dr, nc = c+dc; if (isWithinBoard(nr, nc)) { const t = b[nr] ? b[nr][nc] : null; if (!t || t.color !== col) ms.push({r: nr, c: nc}); if (!commanderSwapUsed[col] && t && t.color === col) ms.push({r: nr, c: nc, isSwap: true}); } } }
            return ms;
        }
        function getKnightLeapMoves(r, c, col) { const m = []; [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr, dc]) => { const nr = r+dr, nc = c+dc; if (isWithinBoard(nr, nc) && (!board[nr] || !board[nr][nc] || board[nr][nc].color !== col)) m.push({r: nr, c: nc}); }); return m; }
        function getPhaseShiftMoves() { const m = []; if (!board) return m; for(let r=0; r<5; r++) { if (!board[r]) continue; for(let c=0; c<5; c++) { if(!board[r][c]) m.push({r, c}); } } return m; }

        /* --- TACTICAL HANDLERS --- */
        function onSquareClick(e) {
            if (isGameOver || !isPlayerTurn || isAnimating) return;
            const r = parseInt(e.currentTarget.dataset.row), c = parseInt(e.currentTarget.dataset.col);
            const p = board[r][c];
            if (selectedPiece) {
                if (selectedPiece.r === r && selectedPiece.c === c) { deselectPiece(); return; }
                const fR = selectedPiece.r, fC = selectedPiece.c;
                let cV = [...validMoves];
                if (activeCard === 'card-knights-leap') cV.push(...getKnightLeapMoves(fR, fC, board[fR][fC].color));
                if (activeCard === 'card-phase-shift') cV = getPhaseShiftMoves();
                const m = cV.find(move => move.r === r && move.c === c);
                if (m) {
                    deselectPiece(); movePiece(fR, fC, r, c, m.isSwap).then(() => {
                        if (activeCard) { runCardsUsed[activeCard] = true; activeCard = null; document.querySelectorAll('.ability-card').forEach(c => c.classList.remove('selected')); updateRunUI(); }
                        switchPlayer();
                    });
                } else if (p && p.color === currentPlayer) selectPiece(r, c);
                else deselectPiece();
            } else if (p && p.color === currentPlayer) selectPiece(r, c);
        }

        function onCardClick(e) { if (isAnimating || !isPlayerTurn) return; const cId = e.currentTarget.id; if (runCardsUsed[cId]) return; if (activeCard === cId) { activeCard = null; e.currentTarget.classList.remove('selected'); } else { document.querySelectorAll('.ability-card').forEach(c => c.classList.remove('selected')); activeCard = cId; e.currentTarget.classList.add('selected'); } if(selectedPiece) selectPiece(selectedPiece.r, selectedPiece.c); }

        /* --- RENDER ENGINE --- */
        function updateRunUI() {
            if (el('challenger-label')) el('challenger-label').textContent = tierTitles[currentStage];
            bossModeTarget = (currentStage === 3) ? 1.0 : 0.0;
            for(let i=0; i<3; i++) {
                const d = el(`dot-${i}`); if(d) d.classList.toggle('active', i <= currentStage);
                const l = el(`line-${i}`); if(l) l.style.backgroundColor = i < currentStage ? '#fff' : 'rgba(255,255,255,0.1)';
            }
            const bL = el('line-2'); if(bL) bL.style.backgroundColor = currentStage >= 3 ? '#fff' : 'rgba(255,255,255,0.1)';
            for(let i=0; i<3; i++) {
                const bD = el(`boss-match-${i}`); if(!bD) continue;
                bD.className = 'dot-boss'; if(bossResults[i] === 'win') bD.classList.add('win'); else if(bossResults[i] === 'loss') bD.classList.add('loss');
            }
            document.querySelectorAll('.ability-card').forEach(c => c.classList.toggle('disabled', !!runCardsUsed[c.id]));
        }

        function updateStatus() { const tI = el('turn-info'); if (tI) tI.textContent = currentPlayer === 'white' ? "Your Turn" : "Enemy Thinking..."; }
        function renderCapturedPieces() { 
            const wC = el('white-captured-pieces'), bC = el('black-captured-pieces'); 
            if(!wC || !bC) return; wC.innerHTML = ''; bC.innerHTML = ''; 
            capturedByWhite.forEach(p => { const div = document.createElement('div'); div.className = 'captured-piece-svg'; div.innerHTML = p.svg; wC.appendChild(div); }); 
            capturedByBlack.forEach(p => { const div = document.createElement('div'); div.className = 'captured-piece-svg'; div.innerHTML = p.svg; bC.appendChild(div); }); 
        }

        function drawIndicators() {
            const aS = el('active-move-overlay'); if(!aS) return; aS.innerHTML = '';
            if (selectedPiece) {
                const aR = 2.2, p = board[selectedPiece.r][selectedPiece.c];
                if (p) {
                    const sM = getValidMoves(p, selectedPiece.r, selectedPiece.c);
                    let eM = [];
                    if (activeCard === 'card-knights-leap') eM = getKnightLeapMoves(selectedPiece.r, selectedPiece.c, p.color);
                    else if (activeCard === 'card-phase-shift') eM = getPhaseShiftMoves();
                    [...sM, ...eM].forEach(m => {
                        const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        dot.setAttribute("cx", 10 + m.c * 20); dot.setAttribute("cy", 10 + m.r * 20); dot.setAttribute("r", aR);
                        dot.setAttribute("class", "move-dot active"); aS.appendChild(dot);
                    });
                }
            }
        }

        function highlightSquares() { document.querySelectorAll('.square').forEach(s => s.classList.remove('selected')); if (selectedPiece) { const s = document.querySelector(`[data-row='${selectedPiece.r}'][data-col='${selectedPiece.c}']`); if (s) s.classList.add('selected'); } }

        function selectPiece(r, c) { deselectPiece(); selectedPiece = { r, c }; const p = board[r][c]; if (!p) return; validMoves = getValidMoves(p, r, c); if (activeCard === 'card-knights-leap') validMoves.push(...getKnightLeapMoves(r, c, p.color)); if (activeCard === 'card-phase-shift') validMoves = getPhaseShiftMoves(); highlightSquares(); drawIndicators(); }
        function deselectPiece() { selectedPiece = null; validMoves = []; highlightSquares(); drawIndicators(); }

        function renderBoard(ani = false) {
            const bE = el('chess-board'); if (!bE) return; bE.innerHTML = '';
            const aO = document.createElementNS("http://www.w3.org/2000/svg", "svg"); aO.id = "active-move-overlay"; aO.setAttribute("viewBox", "0 0 100 100"); aO.setAttribute("preserveAspectRatio", "none"); bE.appendChild(aO);
            const d = calculateCommanderDanger();
            for (let r = 0; r < 5; r++) {
                for (let c = 0; c < 5; c++) {
                    const sq = document.createElement('div'); sq.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`; sq.dataset.row = r; sq.dataset.col = c; sq.style.gridArea = `${r+1} / ${c+1} / ${r+2} / ${c+2}`;
                    if (selectedPiece && selectedPiece.r === r && selectedPiece.c === c) sq.classList.add('selected');
                    if (d.some(danger => danger.r === r && danger.c === c)) sq.classList.add('in-danger');
                    if (board[r] && board[r][c]) {
                        const wr = document.createElement('div'); wr.className = 'piece-wrapper'; wr.innerHTML = board[r][c].svg;
                        const svgEl = wr.querySelector('svg');
                        if (svgEl && ani) { svgEl.classList.add('piece-entrance'); svgEl.style.animationDelay = `${(r * 5 + c) * 0.03}s`; }
                        sq.appendChild(wr);
                    }
                    bE.appendChild(sq);
                }
            }
            document.querySelectorAll('.square').forEach(s => s.onclick = onSquareClick);
            document.querySelectorAll('.ability-card').forEach(card => card.onclick = onCardClick);
            drawIndicators();
        }

        /* --- ACTIONS & FLOW --- */
        function triggerParticles(sq, pCol, dR, dC) {
            const shell = el('board-shell'); if (!shell || !sq) return;
            const r = sq.getBoundingClientRect(), sR = shell.getBoundingClientRect();
            const cX = r.left - sR.left + r.width / 2, cY = r.top - sR.top + r.height / 2;
            const bA = Math.atan2(dR, dC), cols = ['#FFF', '#CCC', '#888', '#444', '#000'];
            for (let i = 0; i < 40; i++) {
                const p = document.createElement('div'); p.className = 'particle'; p.style.left = cX + 'px'; p.style.top = cY + 'px'; p.style.background = cols[Math.floor(Math.random() * cols.length)];
                const isR = Math.random() < 0.3, ang = isR ? (Math.random() * Math.PI * 2) : (bA + (Math.random() - 0.5) * 1.5); 
                const vel = isR ? (40 + Math.random() * 120) : (100 + Math.random() * 250);
                p.style.setProperty('--dx', `${Math.cos(ang) * vel}px`); p.style.setProperty('--dy', `${Math.sin(ang) * vel}px`);
                p.style.setProperty('--start-rot', `${Math.random() * 360}deg`); p.style.setProperty('--mid-rot', `${Math.random() * 720}deg`); p.style.setProperty('--end-rot', `${Math.random() * 1440}deg`);
                p.style.animation = `particleFly ${1.2 + Math.random() * 0.8}s cubic-bezier(0.1, 0.9, 0.2, 1) forwards`; 
                shell.appendChild(p); setTimeout(() => p.remove(), 2500);
            }
            shell.classList.add('impact-shake'); setTimeout(() => shell.classList.remove('impact-shake'), 200);
        }

        async function movePiece(fR, fC, tR, tC, swap = false) {
            isAnimating = true;
            const isP = !!activeCard, pCE = activeCard ? el(activeCard) : null;
            const fSq = document.querySelector(`[data-row='${fR}'][data-col='${fC}']`), tSq = document.querySelector(`[data-row='${tR}'][data-col='${tC}']`);
            const p = board[fR][fC], pEl = fSq ? fSq.querySelector('.piece-wrapper') : null, tP = (board[tR] && board[tR][tC]) ? board[tR][tC] : null;
            
            if (pEl) {
                if (isP) { 
                    pEl.classList.add('piece-power-glow'); if (pCE) pCE.classList.add('executing-power'); 
                    pEl.classList.add('power-fade-out'); await new Promise(r => setTimeout(r, 300)); 
                }
                else { pEl.style.transition = 'none'; pEl.style.transform = 'translate(0, 0)'; void pEl.offsetWidth; fSq.style.zIndex = "1000"; pEl.style.transition = 'transform 0.35s cubic-bezier(0.22, 1, 0.36, 1)'; }
            }
            if (tP && !swap && tSq) { setTimeout(() => { const vPE = tSq.querySelector('.piece-svg'); if (vPE) vPE.style.display = 'none'; triggerParticles(tSq, tP.color, tR - fR, tC - fC); }, 200); }
            if (pEl && fSq && tSq) {
                const fRc = fSq.getBoundingClientRect(), tRc = tSq.getBoundingClientRect();
                if (isP) { pEl.style.transition = 'none'; pEl.style.transform = `translate(${tRc.left - fRc.left}px, ${tRc.top - fRc.top}px)`; pEl.classList.remove('power-fade-out'); pEl.classList.add('power-fade-in'); await new Promise(r => setTimeout(r, 300)); }
                else { pEl.style.transform = `translate(${tRc.left - fRc.left}px, ${tRc.top - fRc.top}px)`; await new Promise(res => setTimeout(res, 370)); }
            }

            if (swap) { const p1 = board[fR][fC], p2 = board[tR][tC]; board[tR][tC] = p1; board[fR][fC] = p2; commanderSwapUsed[currentPlayer] = true; } 
            else { 
                const targetPiece = board[tR][tC]; 
                if (targetPiece) { 
                    currentPlayer === 'white' ? capturedByWhite.push(targetPiece) : capturedByBlack.push(targetPiece); 
                    renderCapturedPieces(); 
                    if (targetPiece.piece === 'commander') isGameOver = true; 
                } 
                board[tR][tC] = p; board[fR][fC] = null; 
            }

            if (!isGameOver && !swap && p && p.piece === 'pawn' && ((p.color === 'white' && tR === 0) || (p.color === 'black' && tR === 4))) {
                if (p.color === 'white') { const choice = await promptPromotion(); board[tR][tC].piece = choice; board[tR][tC].svg = PIECES_SVG[choice]('white'); }
                else { board[tR][tC].piece = 'guardian'; board[tR][tC].svg = PIECES_SVG.guardian('black'); }
            }
            if (pEl) { pEl.classList.remove('piece-power-glow', 'power-fade-in'); if (pCE) pCE.classList.remove('executing-power'); }
            if (fSq) fSq.style.zIndex = ""; renderBoard(); isAnimating = false;
        }

        async function promptPromotion() {
            return new Promise(resolve => {
                const m = el('promotion-modal'); m.classList.add('visible'); el('promo-guardian-icon').innerHTML = PIECES_SVG.guardian('white'); el('promo-assassin-icon').innerHTML = PIECES_SVG.assassin('white');
                const hC = (choice) => { m.classList.remove('visible'); resolve(choice); };
                el('promote-guardian').onclick = () => hC('guardian'); el('promote-assassin').onclick = () => hC('assassin');
            });
        }

        function initializeStage() {
            board = Array.from({ length: 5 }, () => Array(5).fill(null));
            board[4][2] = { piece: 'commander', color: 'white', svg: PIECES_SVG.commander('white') }; board[4][3] = { piece: 'guardian', color: 'white', svg: PIECES_SVG.guardian('white') }; board[4][1] = { piece: 'assassin', color: 'white', svg: PIECES_SVG.assassin('white') };
            board[3][1] = { piece: 'pawn', color: 'white', svg: PIECES_SVG.pawn('white') }; board[3][2] = { piece: 'pawn', color: 'white', svg: PIECES_SVG.pawn('white') }; board[3][3] = { piece: 'pawn', color: 'white', svg: PIECES_SVG.pawn('white') };
            board[0][2] = { piece: 'commander', color: 'black', svg: PIECES_SVG.commander('black') }; board[0][1] = { piece: 'guardian', color: 'black', svg: PIECES_SVG.guardian('black') }; board[0][3] = { piece: 'assassin', color: 'black', svg: PIECES_SVG.assassin('black') };
            board[1][1] = { piece: 'pawn', color: 'black', svg: PIECES_SVG.pawn('black') }; board[1][2] = { piece: 'pawn', color: 'black', svg: PIECES_SVG.pawn('black') }; board[1][3] = { piece: 'pawn', color: 'black', svg: PIECES_SVG.pawn('black') };
            currentPlayer = 'white'; selectedPiece = null; validMoves = []; isGameOver = false; isPlayerTurn = true; commanderSwapUsed = { white: false, black: false }; capturedByWhite = []; capturedByBlack = [];
            activeCard = null; 
            if (currentStage < 3) runCardsUsed = {}; 
            renderBoard(ani = true); renderCapturedPieces(); updateRunUI(); updateStatus();
            el('next-challenger-overlay').classList.remove('visible'); el('game-over-modal').classList.remove('visible'); el('promotion-modal').classList.remove('visible');
        }

        function switchPlayer() {
            if (isGameOver) {
                const wM = el('winner-message'), nCO = el('next-challenger-overlay');
                if (currentPlayer === 'white') {
                    if (currentStage === 3) { bossResults.push('win'); if (bossResults.filter(r => r === 'win').length >= 2) { wM.textContent = 'CONQUERED AETHER'; el('game-over-modal').classList.add('visible'); } else { el('next-challenger-btn').textContent = "NEXT BOSS MATCH"; nCO.classList.add('visible'); el('next-challenger-btn').onclick = () => initializeStage(); } }
                    else { el('next-challenger-btn').textContent = "NEXT CHALLENGER"; nCO.classList.add('visible'); el('next-challenger-btn').onclick = transitionToNextStage; }
                } else {
                    if (currentStage === 3) { bossResults.push('loss'); if (bossResults.filter(r => r === 'loss').length >= 2) { wM.textContent = 'RUN TERMINATED'; el('game-over-modal').classList.add('visible'); } else { el('next-challenger-btn').textContent = "RETRY BOSS MATCH"; el('next-challenger-btn').onclick = () => initializeStage(); nCO.classList.add('visible'); } }
                    else { wM.textContent = 'RUN TERMINATED'; el('game-over-modal').classList.add('visible'); }
                }
                updateRunUI(); return;
            }
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white'; updateStatus(); if (currentPlayer === 'black') { isPlayerTurn = false; setTimeout(makeComputerMove, 800); } else isPlayerTurn = true;
        }

        async function makeComputerMove() { const tI = el('turn-info'); if (tI) tI.textContent = "Enemy Thinking..."; await new Promise(r => setTimeout(r, 50)); const ms = getAllMoves(board, 'black'); if (ms.length === 0) { isGameOver = true; switchPlayer(); return; } let move; if (currentStage === 0) move = ms[Math.floor(Math.random() * ms.length)]; else if (currentStage === 1) { ms.sort((a, b) => ( (board[b.to.r] && board[b.to.r][b.to.c]) ? 1 : 0 ) - ( (board[a.to.r] && board[a.to.r][a.to.c]) ? 1 : 0 )); move = ms[0]; } else move = await asyncMinimaxRoot(currentStage === 3 ? 4 : 3, board, 'black'); await new Promise(r => setTimeout(r, 100)); if (move) await movePiece(move.from.r, move.from.c, move.to.r, move.to.c, move.to.isSwap); switchPlayer(); }
        async function asyncMinimaxRoot(d, cB, pC) { const ms = getAllMoves(cB, pC); let bS = -Infinity, bM = null; for (let i = 0; i < ms.length; i++) { const m = ms[i], s = minimax(d - 1, getBoardAfterMove(cB, m), -Infinity, Infinity, false); if (s > bS) { bS = s; bM = m; } await new Promise(res => setTimeout(res, 0)); } return bM; }
        function transitionToNextStage() { const shell = el('board-container'); if (shell) shell.classList.add('slide-out-left'); setTimeout(() => { runCardsUsed = {}; currentStage++; initializeStage(); if (shell) { shell.style.transition = 'none'; shell.classList.remove('slide-out-left'); shell.classList.add('slide-in-right'); shell.offsetHeight; shell.style.transition = ''; shell.classList.remove('slide-in-right'); shell.classList.add('slide-to-center'); setTimeout(() => shell.classList.remove('slide-to-center'), 600); } }, 600); }
        function minimax(d, cB, a, b, iM) { if (d === 0) return -evaluate(cB); const ms = getAllMoves(cB, iM ? 'black' : 'white'); if (iM) { let best = -Infinity; for (const m of ms) { best = Math.max(best, minimax(d-1, getBoardAfterMove(cB,m), a, b, false)); a = Math.max(a, best); if (b <= a) break; } return best; } else { let best = Infinity; for (const m of ms) { best = Math.min(best, minimax(d-1, getBoardAfterMove(cB,m), a, b, true)); b = Math.min(best, minimax(d-1, getBoardAfterMove(cB,m), a, b, true)); if (b <= a) break; } return best; } }
        function evaluate(b) { let s = 0; const v = { commander: 1000, guardian: 40, assassin: 40, pawn: 10 }; for (let r=0; r<5; r++) for (let c=0; c<5; c++) { const p = (b[r] && b[r][c]) ? b[r][c] : null; if (p) s += (p.color === 'white' ? v[p.piece] : -v[p.piece]); } return s; }
        
        /* --- MENU CONTROLS --- */
        function startRun() { const iS = el('intro-screen'); if (iS) iS.classList.add('fade-out'); setTimeout(() => { currentStage = 0; runCardsUsed = {}; bossResults = []; const mL = el('main-layout'); if (mL) { mL.classList.add('visible'); mL.classList.remove('hidden'); } initializeStage(); }, 800); }
        function resetToMenu() { const mL = el('main-layout'), iS = el('intro-screen'), gOM = el('game-over-modal'); if (mL) { mL.classList.remove('visible'); mL.classList.add('hidden'); } if (gOM) gOM.classList.remove('visible'); if (iS) { iS.style.display = 'flex'; iS.classList.remove('fade-out'); } bossModeTarget = 0; bossModeInterpolation = 0; }

        /* --- SHADER CORE --- */
        function initShader() {
            const canvas = el('bg-canvas'); const gl = canvas.getContext('webgl'); if (!gl) return;
            const vsS = `attribute vec4 aVertexPosition; void main() { gl_Position = aVertexPosition; }`;
            const fsS = `precision highp float; uniform float u_time; uniform vec2 u_resolution; uniform float u_bossMode; float hash(vec2 p) { p = fract(p * vec2(123.34, 456.21)); p += dot(p, p + 45.32); return fract(p.x * p.y); } float noise(vec2 p) { vec2 i = floor(p); vec2 f = fract(p); f = f * f * (3.0 - 2.0 * f); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); return mix(mix(a, b, f.x), mix(c, d, f.x), f.y); } float fbm(vec2 p) { float v = 0.0; float a = 0.5; for (int i = 0; i < 7; i++) { v += a * noise(p); p *= 2.1; a *= 0.5; } return v; } float staticStars(vec2 uv) { vec2 grid = uv * 60.0; vec2 id = floor(grid); vec2 g = fract(grid) - 0.5; float h = hash(id); float d = length(g - (vec2(hash(id + 13.0), hash(id + 47.0)) - 0.5) * 0.9); float sizeFactor = pow(h, 8.0); float finalSize = 0.005 + sizeFactor * 0.065; float star = smoothstep(finalSize, 0.0, d); return (h > 0.80) ? star * (0.6 + sizeFactor * 0.4) : 0.0; } void main() { vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.y, u_resolution.x); float r = length(uv); float angle = atan(uv.y, uv.x); vec2 q = vec2(fbm(uv + u_time * 0.05), fbm(uv + vec2(1.7, 9.2) + u_time * 0.03)); vec2 r_warp = vec2(fbm(uv + 4.0 * q + u_time * 0.04 + vec2(1.7, 9.2)), fbm(uv + 4.0 * q + u_time * 0.02 + vec2(8.3, 2.8))); float spiral = angle + r * (4.5 + 3.0 * fbm(uv * 0.3)) - u_time * 0.1; float pattern = pow(fbm(uv * 2.0 + r_warp * 4.5 + vec2(cos(spiral) * r, sin(spiral) * r) * 1.2) * 1.5, 3.2); vec3 grayColor = mix(vec3(0.001), vec3(0.5, 0.5, 0.55), clamp(pattern, 0.0, 1.0)); vec3 deepRed = vec3(0.18, 0.0, 0.02); vec3 lightPink = vec3(1.0, 0.4, 0.7); vec3 pinkColor = mix(deepRed, lightPink, clamp(pattern, 0.0, 1.0)); vec3 finalCol = mix(grayColor, pinkColor, u_bossMode) + vec3(staticStars(uv)); gl_FragColor = vec4(finalCol * smoothstep(1.8, 0.4, r), 1.0); }`;
            const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vsS); gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fsS); gl.compileShader(fs);
            const program = gl.createProgram(); gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program); gl.useProgram(program);
            const vertices = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
            const buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            const pos = gl.getAttribLocation(program, "aVertexPosition"); gl.enableVertexAttribArray(pos); gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);
            const tLoc = gl.getUniformLocation(program, "u_time"), rLoc = gl.getUniformLocation(program, "u_resolution"), bLoc = gl.getUniformLocation(program, "u_bossMode");
            function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); }
            window.addEventListener('resize', resize); resize();
            function render(time) { 
                gl.uniform1f(tLoc, time * 0.001); gl.uniform2f(rLoc, canvas.width, canvas.height); 
                if (bossModeInterpolation < bossModeTarget) { bossModeInterpolation += 0.016; if(bossModeInterpolation > bossModeTarget) bossModeInterpolation = bossModeTarget; }
                else if (bossModeInterpolation > bossModeTarget) { bossModeInterpolation -= 0.016; if(bossModeInterpolation < bossModeTarget) bossModeInterpolation = bossModeTarget; }
                gl.uniform1f(bLoc, bossModeInterpolation);
                gl.drawArrays(gl.TRIANGLES, 0, 6); requestAnimationFrame(render); 
            }
            requestAnimationFrame(render);
        }

        /* --- ENTRY POINT --- */
        document.addEventListener('DOMContentLoaded', () => {
            initShader(); 
            el('start-challenge-btn').onclick = startRun; el('quit-button').onclick = resetToMenu; el('final-reset-btn').onclick = resetToMenu; 
            const bossBox = el('debug-skip-boss');
            if (bossBox) {
                bossBox.onclick = () => {
                    const m = el('skip-boss-modal'); m.classList.add('visible');
                    el('skip-boss-confirm').onclick = () => { m.classList.remove('visible'); currentStage = 3; bossResults = []; runCardsUsed = {}; initializeStage(); };
                    el('skip-boss-cancel').onclick = () => m.classList.remove('visible');
                };
            }
        });
    </script>
</body>
</html>
